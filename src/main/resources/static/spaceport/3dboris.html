<head>
    <style> body {
        margin: 0;
    } </style>

    <script src="https://unpkg.com/3d-force-graph"></script>
    <!--<script src="../../dist/3d-force-graph.js"></script>-->
</head>

<body>
<div id="3d-graph"></div>

<script src="https://unpkg.com/d3-force-3d"></script>
<script src="https://unpkg.com/d3-octree"></script>

<script src="https://unpkg.com/three"></script>
<script src="https://unpkg.com/three-spritetext"></script>

<script src="https://unpkg.com/dat.gui"></script>
<script type="module">

    // import { UnrealBloomPass } from '//unpkg.com/three/examples/jsm/postprocessing/UnrealBloomPass.js';

    // Random tree
    // const N = 300;
    // const gData = {
    //     nodes: [...Array(N).keys()].map(i => ({ id: i })),
    //     links: [...Array(N).keys()]
    //         .filter(id => id)
    //         .map(id => ({
    //             source: id,
    //             target: Math.round(Math.random() * (id-1))
    //         }))
    // };

    // const Graph = ForceGraph3D()
    // (document.getElementById('3d-graph'))
    // .graphData(gData);

    const elem = document.getElementById("3d-graph");
    const bod = document.getElementById("panel-body");
    const head = document.getElementById("panel-heading");
    var nodes = {};

    const highlightNodes = new Set();
    const highlightLinks = new Set();
    const NODE_REL_SIZE = 1;

    let hoverNode = null;

    let appCount = 0;
    let decCount = 0;
    let sourceCount = 0;
    let varCount = 0;
    let invocationCount = 0;
    let importCount = 0;
    let methodCount = 0;
    let methodParmCount = 0;
    let buildCount = 0;
    let artifactCount = 0;
    let deploymentCount = 0;
    let hostCount = 0;
    let bundleCount = 0;
    let runtimeCount = 0;

    // Controls
    const controls = { 'DAG Orientation': null};
    const gui = new dat.GUI();
    gui.add(controls, 'DAG Orientation', ['lr', 'td', 'zout', 'radialout', null])
        .onChange(orientation => Graph && Graph.dagMode(orientation));

    // This is the Graph definition and all the cool properties
    const Graph = ForceGraph3D()(elem)
        // .enableNodeDrag(true)
        // .onNodeHover(node => elem.style.cursor = node ? 'pointer' : null)
        .dagMode(null)
        .dagLevelDistance(25)
        .onDagError(() => false)
        .d3Force('collision', d3.forceCollide(node => Math.cbrt(node.size) * NODE_REL_SIZE))
        .d3VelocityDecay(0.3)
        .backgroundColor('#FFFFFF')

        // .showNavInfo(true)

        .onNodeHover(node => {

            // no state change
            if ((!node && !highlightNodes.size) || (node && hoverNode === node)) return;

            clearHighLightedNodes();

            highlightNodes.clear();
            highlightLinks.clear();
            if (node) {
                console.log("I am hovering on a node " + node.caption);
                highlightNodes.add(node);
                node.neighbors.forEach(neighbor => highlightNodes.add(neighbor));
                node.links.forEach(link => highlightLinks.add(link));
            }

            hoverNode = node || null;

            updateHighlight();
        })
        .onNodeRightClick(removeNode)
        .onNodeClick(updatePanel)
        .nodeAutoColorBy('label')
        // .nodeColor(d => d.label=="Application" ? '#4caf50' : '#f44336')
        .nodeColor(d => getColor(d.label))

        .nodeVal('size')
        .onNodeDragEnd(node => {
            node.fx = node.x;
            node.fy = node.y;
            node.fz = node.z;

        })
        .nodeLabel(node => `${node.label}: ${node.caption}`)
// This is creating text nodes
//         .nodeThreeObject(node => {
//             const sprite = new SpriteText(node.caption);
//             sprite.material.depthWrite = false; // make sprite background transparent
//             // sprite.color = node.color;
//             sprite.color = getColor(node.label)
//             sprite.textHeight = 2;
//             return sprite;
//         })
        .nodeThreeObject(node => {
            // const imgTexture = new THREE.TextureLoader().load(node => `../images/${node.label}_sprite.png`);
            console.log(node);
            const imgTexture = new THREE.TextureLoader().load(`../images/${node.label}_sprite.png`);
            imgTexture.colorSpace = THREE.SRGBColorSpace;
            const material = new THREE.SpriteMaterial({ map: imgTexture });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(12, 12);
            return sprite;
        })

        .linkLabel(link => `${link.type}`)
        // .linkAutoColorBy('type')
        // .linkAutoColorBy(d => getLinkColor(d.type))
        .linkColor(d => getLinkColor(d.type))


        .linkDirectionalArrowLength(3.5)
        .linkDirectionalArrowRelPos(1)

        // .nodeColor(node => highlightNodes.has(node) ? node === hoverNode ? 'rgb(255,0,0,1)' : 'rgba(255,160,0,0.8)' : 'rgba(0,255,255,0.6)')
        .linkWidth(link => highlightLinks.has(link) ? 4 : 1)
        .linkDirectionalParticles(link => highlightLinks.has(link) ? 4 : 0)
        .linkDirectionalParticleWidth(4)
        .onLinkHover(link => {

            clearHighLightedNodes();

            highlightNodes.clear();

            highlightLinks.clear();

            if (link) {
                highlightLinks.add(link);
                highlightNodes.add(link.source);
                highlightNodes.add(link.target);

            }

            updateHighlight();
        });


    loadIt();

    function loadIt() {
        console.log("Loading it");
        fetch('../spaceport/graphs').then(r => r.json()).then(data => {

            const links = data.map(r => {
                var source = r.source;

                for (const property in source.propertyList) {
                    if (source.propertyList[property].key == 'name') {
                        source.name = source.propertyList[property].value;
                        source.caption = source.name;
                    }
                }
                source.label = source.labels[0];

                source.pig = 'donkey';
                source.neighbors = [];
                source.links = [];
                nodes[source.id] = source;

                var target = r.target;
                // target.id = target.identity.toNumber();
                nodes[target.id] = target;
                target.pig = 'llama';
                target.neighbors = [];
                target.links = [];
                for (const property in target.propertyList) {
                    if (target.propertyList[property].key == 'name') {
                        target.name = target.propertyList[property].value;
                        target.caption = target.name;
                    }

                }
                // target.caption = target.properties["name"];
                target.label = target.labels[0];

                var rel = r.rel;
                source.links.push(r);
                target.links.push(r);
                source.neighbors.push(target);
                target.neighbors.push(source);

                return Object.assign({source: source.id, target: target.id}, rel);
            });

            const ggData = {nodes: Object.values(nodes), links: links};
            crossLink(ggData);
             initIt(ggData);
            Graph.graphData(ggData);
            const bloomPass = new UnrealBloomPass();
            bloomPass.strength = 3;
            bloomPass.radius = 1;
            bloomPass.threshold = 0.1;

            // Graph.postProcessingComposer().addPass(bloomPass);

        });
    }
    function getNodeInListById(gData, id) {
        let location = 0;
        let node = null;
        gData.nodes.forEach(currentNode => {
            if (currentNode.id == id) {
                console.log("Found it at: " + location);
                node = location;
            }
                location ++;
        }

        );
        return node;
    }

    function crossLink(gData) {
        // cross-link node objects
        console.log("Crosslinking!!!!!");
        gData.links.forEach(link => {
            const s = getNodeInListById(gData, link.source);
            const t = getNodeInListById(gData, link.target);

            const a = gData.nodes[s];
            const b = gData.nodes[t];
            // It may be an incomplete graph because of limits
            if ((a != null) && (b != null)) {

                // !a.neighbors && (a.neighbors = []);
                // !b.neighbors && (b.neighbors = []);
                a.neighbors.push(b);
                b.neighbors.push(a);

                // !a.links && (a.links = []);
                // !b.links && (b.links = []);
                a.links.push(link);
                b.links.push(link);
            }

        });
        console.log("Crosslinked I thinked");
    }

    function initIt(gData) {
        gData.nodes.forEach(source => {
            // console.log(source.label);
            if (source.label == 'Application') {
                console.log("I have an Application");
                appCount++;
                // oink = document.getElementById("appCount");
                // oink.innerText = appCount;
                // applicationBtn = document.getElementById("applicationBtn");
                // applicationBtn.style.backgroundColor = getColor("Application");
                // applicationBtn.style.borderColor = getColor("Application");
                // source.size = getSize(source.label);


            }
            if (source.label == 'Declaration') {
                console.log("I have a Declaration");
                decCount++;
                // document.getElementById("decCount").innerText = decCount;
                // declarationBtn = document.getElementById("declarationBtn");
                // declarationBtn.style.backgroundColor = getColor("Declaration");
                // declarationBtn.style.borderColor = getColor("Declaration");
                // console.log("Size matters: " + source.size);
                // source.size = getSize(source.label);
            }
            if (source.label == 'SourceModel') {
                console.log("I have a SourceModel");
                sourceCount++;
                // document.getElementById("sourceCount").innerText = sourceCount;
                // sourceModelBtn = document.getElementById("sourceModelBtn");
                // sourceModelBtn.style.backgroundColor = getColor("SourceModel");
                // sourceModelBtn.style.borderColor = getColor("SourceModel");
                // source.size = getSize(source.label);
            }
            if (source.label == 'Variable') {
                console.log("I have a Variable");
                varCount++;
                // document.getElementById("varCount").innerText = varCount;
                // variablelBtn = document.getElementById("variableBtn");
                // variablelBtn.style.backgroundColor = getColor("Variable");
                // variablelBtn.style.borderColor = getColor("Variable");
                // source.size = getSize(source.label);
                // source.size = 25;
            }
            if (source.label == 'Invocation') {
                console.log("I have a Invocation");
                invocationCount++;
                // document.getElementById("invoCount").innerText = invocationCount;
                // invocationBtn = document.getElementById("invocationBtn");
                // invocationBtn.style.backgroundColor = getColor("Invocation");
                // invocationBtn.style.borderColor = getColor("Invocation");
                // source.size = getSize(source.label);
            }
            if (source.label == 'Import') {
                console.log("I have a Import");
                importCount++;
                // document.getElementById("importCount").innerText = importCount;
                // importBtn = document.getElementById("importBtn");
                // importBtn.style.backgroundColor = getColor("Import");
                // importBtn.style.borderColor = getColor("Import");
                // source.size = getSize(source.label);
            }
            if (source.label == 'Method') {
                console.log("I have a Method");
                methodCount++;
                // document.getElementById("methodCount").innerText = methodCount;
                // methodBtn = document.getElementById("methodBtn");
                // methodBtn.style.backgroundColor = getColor("Method");
                // methodBtn.style.borderColor = getColor("Method");
                // source.size = getSize(source.label);
            }
            if (source.label == 'MethodParm') {
                console.log("I have a MethodParm");
                methodParmCount++;
                // document.getElementById("parmCount").innerText = methodParmCount.toString();
                // methodParmBtn = document.getElementById("methodParmBtn");
                // methodParmBtn.style.backgroundColor = getColor("MethodParm");
                // methodParmBtn.style.borderColor = getColor("MethodParm");
                // source.size = getSize(source.label);
            }
            if (source.label == 'Build') {
                console.log("I have a Build");
                buildCount++;
                // document.getElementById("buildCount").innerText = buildCount.toString();
                // buildBtn = document.getElementById("buildBtn");
                // buildBtn.style.backgroundColor = getColor("Build");
                // buildBtn.style.borderColor = getColor("Build");
                // source.size = getSize(source.label);
            }
            if (source.label == 'Artifact') {
                console.log("I have an Artifact");
                artifactCount++;
                // document.getElementById("artifactCount").innerText = artifactCount.toString();
                // artifacBtn = document.getElementById("artifactBtn");
                // artifacBtn.style.backgroundColor = getColor("Artifact");
                // artifacBtn.style.borderColor = getColor("Artifact");
                // source.size = getSize(source.label);
            }
            if (source.label == 'Deployment') {
                console.log("I have a Deployment");
                deploymentCount++;
                // document.getElementById("deploymentCount").innerText = deploymentCount.toString();
                //
                // deploymentBtn = document.getElementById("deploymentBtn");
                // deploymentBtn.style.backgroundColor = getColor("Deployment");
                // deploymentBtn.style.borderColor = getColor("Deployment");
                // source.size = getSize(source.label);
            }
            if (source.label == 'RuntimeEnv') {
                console.log("I have a RuntimeEnv");
                runtimeCount++;
                // document.getElementById("runtimeCount").innerText = runtimeCount.toString();
                // runtimeBtn = document.getElementById("runtimeBtn");
                // runtimeBtn.style.backgroundColor = getColor("RuntimeEnv");
                // runtimeBtn.style.borderColor = getColor("RuntimeEnv");
                // source.size = getSize(source.label);
            }
            if (source.label == 'Host') {
                console.log("I have a Host");
                hostCount++;
                // document.getElementById("hostCount").innerText = hostCount.toString();
                // hostBtn = document.getElementById("hostBtn");
                // hostBtn.style.backgroundColor = getColor("Host");
                // hostBtn.style.borderColor = getColor("Host");
                // source.size = getSize(source.label);
            }
            if (source.label == 'Bundle') {
                console.log("I have a Bundle");
                bundleCount++;
                // document.getElementById("bundleCount").innerText = bundleCount.toString();
                // bundleBtn = document.getElementById("bundleBtn");
                // bundleBtn.style.backgroundColor = getColor("Bundle");
                // bundleBtn.style.borderColor = getColor("Bundle");
                // source.size = getSize(source.label);
            }
            if (source.label == 'Service') {
                console.log("I have a Service");
                // bundleCount++;
                // document.getElementById("bundleCount").innerText = bundleCount.toString();
                // bundleBtn = document.getElementById("bundleBtn");
                // bundleBtn.style.backgroundColor = getColor("Bundle");
                // bundleBtn.style.borderColor = getColor("Bundle");
                // source.size = getSize(source.label);
            }
            if (source.label == 'Topic') {
                console.log("I have a Topic");
                // bundleCount++;
                // document.getElementById("bundleCount").innerText = bundleCount.toString();
                // bundleBtn = document.getElementById("bundleBtn");
                // bundleBtn.style.backgroundColor = getColor("Bundle");
                // bundleBtn.style.borderColor = getColor("Bundle");
                // source.size = getSize(source.label);
            }
            if (source.label == 'External') {
                console.log("I have an External");
                // bundleCount++;
                // document.getElementById("bundleCount").innerText = bundleCount.toString();
                // bundleBtn = document.getElementById("bundleBtn");
                // bundleBtn.style.backgroundColor = getColor("Bundle");
                // bundleBtn.style.borderColor = getColor("Bundle");
                // source.size = getSize(source.label);
            }
            if (source.label == 'AntiCorruptionLayer') {
                console.log("I have an AntiCorruptionLayer");
                // bundleCount++;
                // document.getElementById("bundleCount").innerText = bundleCount.toString();
                // bundleBtn = document.getElementById("bundleBtn");
                // bundleBtn.style.backgroundColor = getColor("Bundle");
                // bundleBtn.style.borderColor = getColor("Bundle");
                // source.size = getSize(source.label);
            }
            source.size = getSize(source.label);
            // console.log("I have a " + source.label);
        });
    }

    function removeNode(node) {
        let {nodes, links} = Graph.graphData();
        links = links.filter(l => l.source !== node && l.target !== node); // Remove links attached to node
        nodes.splice(node.id, 1); // Remove node
        nodes.forEach((n, idx) => {
            n.id = idx;
        }); // Reset node ids to array index
        Graph.graphData({nodes, links});
    }

    function collapseNode(node) {
        let {nodes, links} = Graph.graphData();
        node.collapsed = !node.collapsed;
        Graph.graphData({nodes, links});
    }

    function updatePanel(node) {
        console.log(node.caption);
        // leftbar.contentRemove();
        // leftbar.content.append(node.caption);
        // leftbar.content.innerHTML += "<div>";
        let content = "<table class=\"table\">\n" +
            "  <thead>\n" +
            "    <tr >\n" +

            "      <th scope=\"col\">Property</th>\n" +
            "      <th scope=\"col\">Value</th>\n" +

            "    </tr>\n" +
            "  </thead>\n" +
            "  <tbody>\n";
        for (const property in node.properties) {
            // leftbar.content.append(`${property}: ${node.properties[property]}`);
            // let line = `${property}: ${node.properties[property]}`;
            let line = "<tr>\n" +
                // "      <th scope=\"row\">Property</th>\n" +
                "      <td >" + `${property}` + "</td>\n" +
                "      <td >" + `${node.properties[property]}` + "</td>\n" +

                "    </tr>\n";
            // leftbar.content.innerHTML += "<p class=\"text-sm\">" + line + "</p>";
            // leftbar.content.innerHTML += "<p padding=\"20px\">" + line + "</p>";
            content += line + "\n";

        }

        content += "</tbody>\n" +
            "</table>";


        // leftbar.content.innerHTML += "</div>"
        // leftbar.setHeaderTitle(node.label);
        // collapseNode(node);
        bod.innerHTML = content;

        // bod.innerHTML = "<table class=\"table\">\n" +
        //     "  <thead>\n" +
        //     "    <tr>\n" +
        //     "      <th scope=\"col\">#</th>\n" +
        //     "      <th scope=\"col\">First</th>\n" +
        //     "      <th scope=\"col\">Last</th>\n" +
        //     "      <th scope=\"col\">Handle</th>\n" +
        //     "    </tr>\n" +
        //     "  </thead>\n" +
        //     "  <tbody>\n" +
        //     "    <tr>\n" +
        //     "      <th scope=\"row\">1</th>\n" +
        //     "      <td>Mark</td>\n" +
        //     "      <td>Otto</td>\n" +
        //     "      <td>@mdo</td>\n" +
        //     "    </tr>\n" +
        //     "    <tr>\n" +
        //     "      <th scope=\"row\">2</th>\n" +
        //     "      <td>Jacob</td>\n" +
        //     "      <td>Thornton</td>\n" +
        //     "      <td>@fat</td>\n" +
        //     "    </tr>\n" +
        //     "    <tr>\n" +
        //     "      <th scope=\"row\">3</th>\n" +
        //     "      <td>Larry</td>\n" +
        //     "      <td>the Bird</td>\n" +
        //     "      <td>@twitter</td>\n" +
        //     "    </tr>\n" +
        //     "  </tbody>\n" +
        //     "</table>"
        head.innerText = node.label;

    }

    function updateHighlight() {

        // trigger update of highlighted objects in scene
        // highlightNodes.forEach(node => {
        //     node.size = 50;
        // });
        highlightLinks.forEach(link => {

            console.log("Highligting link: " + link.type);

            console.log("Updating the highlights");
            Graph

                .nodeColor(Graph.nodeColor())
                .linkWidth(Graph.linkWidth())
                .linkDirectionalParticles(Graph.linkDirectionalParticles());

        });
    }

    function getColor(type) {

        if (type == "Application") return '#FF8c00';
        else if (type == "SourceModel") return '#2E8B57';
        else if (type == "Declaration") return '#FFD700';
        else if (type == "Import") return '#00BFFF';
        else if (type == "Invocation") return '#CD5C5C';
        else if (type == "Method") return '#BA55D3';
        else if (type == "MethodParam") return '#778899';
        else if (type == "Variable") return '#4169E1';
        else if (type == "Build") return '#89ff65';
        else if (type == "Artifact") return '#C71585';
        else if (type == "Deployment") return '#b1c798';
        else if (type == "Bundle") return '#ffb790';
        else if (type == "RuntimeEnv") return '#7c3c29';
        else if (type == "Host") return '#d6d2dc';
        else if (type == "Service") return "#2d86e3";
        else if (type == "Topic") return "#f12309";
        else if (type == "External") return "#63ec1f";
        else if (type == "AntiCorruptionLayer") return "#ea701a";
        else return '#762dff'

    }

    function getLinkColor(type) {

        if (type == "API_CALL") return '#4169E1';

        else if (type == "SUBSCRIBE") return "#f12309";
        else if (type == "PUBLISH") return "#f12309";

        else return '#21ea1a'

    }

    function getSize(type) {

        if (type == "Application") return 50;
        else if (type == "SourceModel") return null;
        else if (type == "Declaration") return null;
        else if (type == "Import") return null;
        else if (type == "Invocation") return null;
        else if (type == "Method") return null;
        else if (type == "MethodParam") return null;
        else if (type == "Variable") return null;
        else if (type == "Build") return null;
        else if (type == "Artifact") return null;
        else if (type == "Deployment") return null;
        else if (type == "Bundle") return 25;
        else if (type == "RuntimeEnv") return 30;
        else if (type == "Host") return 30;
        else if (type == "Service") return null;
        else if (type == "External") return null;
        else if (type == "Topic") return null;
        else if (type == "AntiCorruptionLayer") return null;
        else return null;

    }

    function initLabels() {

        oink = document.getElementById("appCount");
        oink.innerText = appCount;
        applicationBtn = document.getElementById("applicationBtn");
        applicationBtn.style.backgroundColor = getColor("Application");
        applicationBtn.style.borderColor = getColor("Application");

        document.getElementById("decCount").innerText = decCount;
        declarationBtn = document.getElementById("declarationBtn");
        declarationBtn.style.backgroundColor = getColor("Declaration");
        declarationBtn.style.borderColor = getColor("Declaration");

        document.getElementById("sourceCount").innerText = sourceCount;
        sourceModelBtn = document.getElementById("sourceModelBtn");
        sourceModelBtn.style.backgroundColor = getColor("SourceModel");
        sourceModelBtn.style.borderColor = getColor("SourceModel");

        document.getElementById("varCount").innerText = varCount;
        variablelBtn = document.getElementById("variableBtn");
        variablelBtn.style.backgroundColor = getColor("Variable");
        variablelBtn.style.borderColor = getColor("Variable");

        document.getElementById("invoCount").innerText = invocationCount;
        invocationBtn = document.getElementById("invocationBtn");
        invocationBtn.style.backgroundColor = getColor("Invocation");
        invocationBtn.style.borderColor = getColor("Invocation");

        document.getElementById("importCount").innerText = importCount;
        importBtn = document.getElementById("importBtn");
        importBtn.style.backgroundColor = getColor("Import");
        importBtn.style.borderColor = getColor("Import");

        document.getElementById("methodCount").innerText = methodCount;
        methodBtn = document.getElementById("methodBtn");
        methodBtn.style.backgroundColor = getColor("Method");
        methodBtn.style.borderColor = getColor("Method");

        document.getElementById("parmCount").innerText = methodParmCount.toString();
        methodParmBtn = document.getElementById("methodParmBtn");
        methodParmBtn.style.backgroundColor = getColor("MethodParm");
        methodParmBtn.style.borderColor = getColor("MethodParm");

        document.getElementById("buildCount").innerText = buildCount.toString();
        buildBtn = document.getElementById("buildBtn");
        buildBtn.style.backgroundColor = getColor("Build");
        buildBtn.style.borderColor = getColor("Build");

        document.getElementById("deploymentCount").innerText = deploymentCount.toString();
        deploymentBtn = document.getElementById("deploymentBtn");
        deploymentBtn.style.backgroundColor = getColor("Deployment");
        deploymentBtn.style.borderColor = getColor("Deployment");

        document.getElementById("artifactCount").innerText = artifactCount.toString();
        artifacBtn = document.getElementById("artifactBtn");
        artifacBtn.style.backgroundColor = getColor("Artifact");
        artifacBtn.style.borderColor = getColor("Artifact");

    }

    function clearHighLightedNodes() {
        highlightNodes.forEach((node => {
            node.size = getSize(node.label);

        }));
    }

    function borderIt(butt) {
        console.log("Clicked");

        console.log("The id is: " + butt.id);
        butt.style.backgroundColor = '#d3d3d3';
        if (butt.id == "noneBtn") {
            Graph.dagMode(null);
            dagMode = "noneBtn";

        } else {
            document.getElementById(dagMode).style.backgroundColor = '#FFFFFF';
            dagMode = butt.id;
            Graph.dagMode(butt.id);
        }
        // oink = document.getElementById(butt.id);
        // oink.style.backgroundColor = '#2E8B57';

    }

    function removeNodeTypes(nodeType) {
        let {nodes, links} = Graph.graphData();
        nodes.forEach(node => {
            if (node.label == nodeType) {
                links = links.filter(l => l.source !== node && l.target !== node); // Remove links attached to node
                nodes.splice(node.id, 1); // Remove node
                nodes.forEach((n, idx) => {
                    n.id = idx;
                }); // Reset node ids to array index

            }

        });
        Graph.graphData({nodes, links});
    }

    function resetCamera() {
        // alert("Resetting Camera. Current is: " + Graph.cameraPosition(0,0,0));
        // Graph.cameraPosition(
        //     { x: 0, y: 0, z: 0 }, // new position
        //     null, // lookAt ({ x, y, z })
        //     3000  // ms transition duration
        // );
        // Graph.cameraPosition();
        // Graph.zoomToFit(500);
        var cam = Graph.camera();
        cam.position.x = 0;
        cam.position.y = 0;
        // cam.position.z = 1770;
        cam.rotation.x = -0;
        cam.rotation.y = 0;
        cam.rotation.z = -0;
        cam.up.x = 0;
        cam.up.y = 1;
        cam.up.z = 0;
        Graph.zoomToFit(500);
    }


</script>

</body>